

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>algorithms.homology_mod2 &mdash; HyperNetX 0.3.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../_static/copybutton.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> HyperNetX
          

          
            
            <img src="../../_static/hnx_logo_smaller.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installing HyperNetX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../classes/modules.html">Hypergraphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../algorithms/modules.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../drawing/modules.html">Drawing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reports/modules.html">Reports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">HyperNetX</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>algorithms.homology_mod2</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for algorithms.homology_mod2</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Homology and Smith Normal Form</span>
<span class="sd">==============================</span>
<span class="sd">The purpose of computing the Homology groups for data generated </span>
<span class="sd">hypergraphs is to identify data sources that correspond to interesting </span>
<span class="sd">features in the topology of the hypergraph. </span>

<span class="sd">The elements of one of these Homology groups are generated by $k$ </span>
<span class="sd">dimensional cycles of relationships in the original data that are not </span>
<span class="sd">bound together by higher order relationships. Ideally, we want the </span>
<span class="sd">briefest description of these cycles; we want a minimal set of </span>
<span class="sd">relationships exhibiting interesting cyclic behavior. This minimal set </span>
<span class="sd">will be a bases for the Homology group.</span>

<span class="sd">The cyclic relationships in the data are discovered using a **boundary </span>
<span class="sd">map** represented as a matrix. To discover the bases we compute the </span>
<span class="sd">**Smith Normal Form** of the boundary map.</span>

<span class="sd">Homology Mod2</span>
<span class="sd">-------------</span>
<span class="sd">This module computes the homology groups for data represented as an</span>
<span class="sd">abstract simplicial complex with chain groups $\{C_k\}$ and $Z_2$ additions.  </span>
<span class="sd">The boundary matrices are represented as rectangular matrices over $Z_2$.</span>
<span class="sd">These matrices are diagonalized and represented in Smith</span>
<span class="sd">Normal Form. The kernel and image bases are computed and the Betti</span>
<span class="sd">numbers and homology bases are returned.</span>

<span class="sd">Methods for obtaining SNF for Z/2Z are based on Ferrario&#39;s work:</span>
<span class="sd">http://www.dlfer.xyz/post/2016-10-27-smith-normal-form/</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">hypernetx</span> <span class="k">as</span> <span class="nn">hnx</span>
<span class="kn">import</span> <span class="nn">warnings</span><span class="o">,</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">hypernetx</span> <span class="k">import</span> <span class="n">HyperNetXError</span>

<div class="viewcode-block" id="kchainbasis"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.kchainbasis">[docs]</a><span class="k">def</span> <span class="nf">kchainbasis</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the set of k dimensional cells in the abstract simplicial </span>
<span class="sd">    complex associated with the hypergraph. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h : hnx.Hypergraph</span>
<span class="sd">    k : int</span>
<span class="sd">        dimension of cell</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : list</span>
<span class="sd">        an ordered list of kchains represented as tuples of length k+1</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    hnx.hypergraph.toplexes</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Method works best if h is simple [Berge], i.e. no edge contains another and there are no duplicate edges (toplexes). </span>
<span class="sd">    - Hypergraph node uids must be sortable.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
    <span class="n">kchains</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">kchains</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">uidset</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">kchains</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">uidset</span><span class="p">),</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kchains</span><span class="p">))</span></div>

<div class="viewcode-block" id="interpret"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.interpret">[docs]</a><span class="k">def</span> <span class="nf">interpret</span><span class="p">(</span><span class="n">Ck</span><span class="p">,</span><span class="n">arr</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the data as represented in Ck associated with the arr</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Ck : list</span>
<span class="sd">        a list of k-cells being referenced by arr</span>
<span class="sd">    arr : np.array</span>
<span class="sd">        a 0-1 array</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    ----</span>
<span class="sd">    : list</span>
<span class="sd">        list of k-cells referenced by data in Ck</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ck</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s1">&#39;elements of arr must have the same length as Ck&#39;</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Ck</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span> <span class="k">if</span> <span class="n">vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="bkMatrix"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.bkMatrix">[docs]</a><span class="k">def</span> <span class="nf">bkMatrix</span><span class="p">(</span><span class="n">km1basis</span><span class="p">,</span><span class="n">kbasis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the boundary map from $C_{k-1}$-basis to $C_k$ basis with </span>
<span class="sd">    respect to $Z_2$</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    km1basis : indexable iterable </span>
<span class="sd">        Ordered list of $k-1$ dimensional cell </span>
<span class="sd">    kbasis : indexable iterable </span>
<span class="sd">        Ordered list of $k$ dimensional cells</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bk : np.array</span>
<span class="sd">        boundary matrix in $Z_2$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">km1basis</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">kbasis</span><span class="p">)),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">kbasis</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="p">)):</span>
            <span class="n">face</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span><span class="o">+</span><span class="n">cell</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">km1basis</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">kbasis</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
            <span class="n">bk</span><span class="p">[</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">]</span><span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">bk</span></div>

<span class="k">def</span> <span class="nf">_rswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">M</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth row of M</span>
<span class="sd">    Returns a new matrix </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    M : np.array</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">        copy of M with ith and jth row exchanged</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">N</span>

<span class="k">def</span> <span class="nf">_cswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth column of M</span>
<span class="sd">    Returns a new matrix </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    M : np.array</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">        copy of M with ith and jth column exchanged    </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">N</span> <span class="o">=</span> <span class="n">_rswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">N</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

<div class="viewcode-block" id="swap_rows"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.swap_rows">[docs]</a><span class="k">def</span> <span class="nf">swap_rows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth row of each matrix in args</span>
<span class="sd">    Returns a list of new matrices </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    M : np.array</span>
<span class="sd">    args : np.arrays</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        list of np.arrays, copies of args with ith and jth row swapped</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_rswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">M</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="swap_columns"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.swap_columns">[docs]</a><span class="k">def</span> <span class="nf">swap_columns</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth column of each matrix in args</span>
<span class="sd">    Returns a list of new matrices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    M : np.array</span>
<span class="sd">    args : np.arrays</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        list of np.arrays, copies of args with ith and jth column </span>
<span class="sd">        swapped</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_cswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">M</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="add_to_row"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.add_to_row">[docs]</a><span class="k">def</span> <span class="nf">add_to_row</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">ri</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">rj</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces row i (of M) with sum ri multiple of ith row and rj multiple of jth row</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        matrix</span>
<span class="sd">    i : int</span>
<span class="sd">        index of row being altered</span>
<span class="sd">    j : int</span>
<span class="sd">        index of row being added to altered</span>
<span class="sd">    ri : int, optional</span>
<span class="sd">        Multiplier for ith row</span>
<span class="sd">    rj : int, optional</span>
<span class="sd">        Multiplier for jth row</span>
<span class="sd">    mod : int, optional </span>
<span class="sd">        modular addition to be used</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">        copy of M with ith row replaced with sum of multiples of ith row</span>
<span class="sd">        and jth row</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">ri</span><span class="o">*</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">rj</span><span class="o">*</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],[</span><span class="n">mod</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">N</span></div>

<div class="viewcode-block" id="add_to_column"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.add_to_column">[docs]</a><span class="k">def</span> <span class="nf">add_to_column</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">ci</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">cj</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces column i (of M) with sum ci multiple of ith column and cj multiple of jth column</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        matrix </span>
<span class="sd">    i : int</span>
<span class="sd">        index of column being altered</span>
<span class="sd">    j : int</span>
<span class="sd">        index of column being added to altered</span>
<span class="sd">    ri : int, optional</span>
<span class="sd">        Multiplier for ith column</span>
<span class="sd">    rj : int, optional</span>
<span class="sd">        Multiplier for jth column</span>
<span class="sd">    mod : int, optional </span>
<span class="sd">        modular addition to be used</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">        copy of M with ith row replaced with sum of multiples of ith row</span>
<span class="sd">        and jth row</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">add_to_row</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">ci</span><span class="p">,</span><span class="n">cj</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>

<div class="viewcode-block" id="modmult"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.modmult">[docs]</a><span class="k">def</span> <span class="nf">modmult</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix multiplication modulo a positive integer</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M, N : np.array, dtype=int</span>
<span class="sd">        M,N must be two dimensional and appropriate dimensions for </span>
<span class="sd">        matrix multiplication</span>
<span class="sd">    mod : int</span>
<span class="sd">        modulus for modulo operations on elements of product</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">mod</span><span class="p">)</span></div>

<div class="viewcode-block" id="matmulreduce"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.matmulreduce">[docs]</a><span class="k">def</span> <span class="nf">matmulreduce</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively multiples a list of matrices.</span>

<span class="sd">    For arr = [arr[0],arr[1],arr[2]...arr[n]] returns product arr[0]arr[1]...arr[n]</span>
<span class="sd">    If reverse = True, returns product arr[n]arr[n-1]...arr[0]</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : list of np.array</span>
<span class="sd">        list of nxm matrices represented as np.array</span>
<span class="sd">    reverse : bool, optional</span>
<span class="sd">        order to multiply the matrices</span>
<span class="sd">    mod : int, optional</span>
<span class="sd">        modulus for modulo operations on elements of products</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : np.array</span>
<span class="sd">        Product of matrices in the list</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">modmult</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">P</span></div>
    
<div class="viewcode-block" id="matsumreduce"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.matsumreduce">[docs]</a><span class="k">def</span> <span class="nf">matsumreduce</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively adds a list of matrices.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : list of np.array</span>
<span class="sd">        list of nxm matrices represented as np.array</span>
<span class="sd">    mod : int, optional</span>
<span class="sd">        modulus for modulo operations on elements of sums</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    S : np.array</span>
<span class="sd">        Sum of matrices in the list</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">S</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">S</span> <span class="o">+</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],[</span><span class="n">mod</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">S</span></div>

<span class="c1">## Convenience methods for computing Smith Normal Form </span>
<span class="c1">## All of these operations have themselves as inverses </span>

<span class="k">def</span> <span class="nf">_sr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">swap_rows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_sc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">R</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">swap_columns</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_ar</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">add_to_row</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">),</span><span class="n">add_to_row</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_ac</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">add_to_column</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">),</span><span class="n">add_to_column</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_get_next_pivot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the first r,c indices in the submatrix of M starting</span>
<span class="sd">    with row s1 and column s2 index (row,col) that is nonzero, </span>
<span class="sd">    if it exists.</span>

<span class="sd">    Search starts with the s2th column and looks for the first nonzero</span>
<span class="sd">    s1 row. If none is found, search continues to the next column and so </span>
<span class="sd">    on.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        matrix represented as np.array</span>
<span class="sd">    s1 : int</span>
<span class="sd">        index of row position to start submatrix of M</span>
<span class="sd">    s2 : int, optional, default = s1</span>
<span class="sd">        index of column position to start submatrix of M</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (r,c) : tuple of int or None</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># find the next nonzero pivot to put in s,s spot for Smith Normal Form</span>
    <span class="n">m</span><span class="p">,</span><span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s2</span><span class="p">:</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="smith_normal_form_mod2"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.smith_normal_form_mod2">[docs]</a><span class="k">def</span> <span class="nf">smith_normal_form_mod2</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">track</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the invertible transformation matrices needed to compute the </span>
<span class="sd">    Smith Normal Form of M modulo 2</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        a rectangular matrix with elements in $Z_2$</span>
<span class="sd">    track : bool</span>
<span class="sd">        if track=True will print out the transformation as it </span>
<span class="sd">        discovers L[i] and R[j]</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L, R, S, Linv : np.arrays</span>
<span class="sd">        LMR = S is the Smith Normal Form of the matrix M. </span>
<span class="sd">    </span>
<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Given a mxn matrix $M$ with </span>
<span class="sd">    entries in $Z_2$ we start with the equation: $L[0] M R[0] = S$, where </span>
<span class="sd">    $L[0] = I_m$, and $R[0]=I_n$ are identity matrices and $S = M$. We </span>
<span class="sd">    repeatedly multiply the left and right side of the equation by </span>
<span class="sd">    invertible matrices $L[i]$ and $R[j]$ to transform S into a diagonal </span>
<span class="sd">    matrix. At the end we verify the product:</span>
<span class="sd">    $$L M R = S.$$</span>
<span class="sd">    where $L = L[s]L[s-1]...L[1]L[0]$ and $R = R[0]R[1]...R[t]$.</span>
<span class="sd">       </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">dimL</span><span class="p">,</span><span class="n">dimR</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="mi">2</span>
    
    <span class="c1">## initialize left and right transformations with identity matrices</span>
    <span class="n">IL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">IR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimR</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimR</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>    

    <span class="n">Linv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="s1">&#39;L</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>  
        <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="s1">&#39;M</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="s1">&#39;R</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span><span class="n">dimR</span><span class="p">)):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">),</span>
        <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">s=</span><span class="si">{s}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1">## Find index pair (rdx,cdx) with value 1 in submatrix M[s:,s:] </span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">_get_next_pivot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rdx</span><span class="p">,</span><span class="n">cdx</span> <span class="o">=</span> <span class="n">pivot</span>
        <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;/nPivot=</span><span class="si">{rdx}</span><span class="s1">,</span><span class="si">{cdx}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1">## Swap rows and columns as needed so that 1 is in the s,s position</span>
        <span class="k">if</span> <span class="n">rdx</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">_sr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">rdx</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
            <span class="n">Linv</span> <span class="o">=</span> <span class="n">swap_columns</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">rdx</span><span class="p">,</span><span class="n">Linv</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">f</span><span class="s1">&#39;L</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="s1">&#39;S</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,)</span> 
        <span class="k">if</span> <span class="n">cdx</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span><span class="n">R</span><span class="o">=</span> <span class="n">_sc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">cdx</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="s1">&#39;S</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">f</span><span class="s1">&#39;R</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> 

        <span class="c1"># add sth row to every row with 1 in sth column &amp; sth column to every column with 1 in sth row</span>
        <span class="n">row_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dimL</span><span class="p">)</span> <span class="k">if</span> <span class="n">S</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">rdx</span> <span class="ow">in</span> <span class="n">row_indices</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">_ar</span><span class="p">(</span><span class="n">rdx</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">)</span>
            <span class="n">Linv</span> <span class="o">=</span> <span class="n">add_to_column</span><span class="p">(</span><span class="n">Linv</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">rdx</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">f</span><span class="s1">&#39;L</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="s1">&#39;S</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,)</span> 
        <span class="n">column_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">jdx</span> <span class="k">for</span> <span class="n">jdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dimR</span><span class="p">)</span> <span class="k">if</span> <span class="n">S</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">jdx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">jdx</span><span class="p">,</span><span class="n">cdx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">column_indices</span><span class="p">):</span>
            <span class="n">S</span><span class="p">,</span><span class="n">R</span> <span class="o">=</span> <span class="n">_ac</span><span class="p">(</span><span class="n">cdx</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">R</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">f</span><span class="s1">&#39;R</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="s1">&#39;S</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,)</span> 
    <span class="k">return</span> <span class="n">L</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">Linv</span></div>

        
<div class="viewcode-block" id="reduced_row_echelon_form_mod2"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.reduced_row_echelon_form_mod2">[docs]</a><span class="k">def</span> <span class="nf">reduced_row_echelon_form_mod2</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">track</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the invertible transformation matrices needed to compute </span>
<span class="sd">    the reduced row echelon form of M modulo 2</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        a rectangular matrix with elements in $Z_2$</span>
<span class="sd">    track</span>
<span class="sd">        bool</span>
<span class="sd">        if track=True will print out the transformation as it </span>
<span class="sd">        discovers L[i] </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L, S, Linv : np.arrays </span>
<span class="sd">        LM = S where S is the reduced echelon form of M</span>
<span class="sd">        and M = LinvS    </span>
<span class="sd">        </span>
<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    To get the reduced row echelon form for M of dimensions mxn we </span>
<span class="sd">    start with the equation: I(m) M = S,</span>
<span class="sd">    where I(m) is the identity matrix and S starts out equal to M.</span>
<span class="sd">    We repeatedly multiply the left side of both sides of the equation </span>
<span class="sd">    by invertible matrices </span>
<span class="sd">    L[i] to transform S into reduced row echelon form. At the end we </span>
<span class="sd">    verify the product:</span>
<span class="sd">    L[s]L[s-1]...L[0] M = S .    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">dimL</span><span class="p">,</span><span class="n">dimR</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="mi">2</span>
    
    <span class="c1">## method with numpy</span>
    <span class="n">IL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="n">Linv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="s1">&#39;L</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>  
        <span class="nb">print</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="s1">&#39;M</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimR</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">s1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="n">dimL</span><span class="p">):</span>
            <span class="c1">## Find index pair (rdx,cdx) with value 1 in submatrix M[s1:,:]</span>
            <span class="c1">## look for the first 1 in the s2 column</span>
            <span class="n">pivot</span> <span class="o">=</span> <span class="n">_get_next_pivot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pivot</span><span class="p">:</span>
                <span class="n">rdx</span><span class="p">,</span><span class="n">cdx</span> <span class="o">=</span> <span class="n">pivot</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="n">cdx</span>
                <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;/nPivot=</span><span class="si">{rdx}</span><span class="s1">,</span><span class="si">{cdx}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">break</span>           
                <span class="c1">## Swap rows as needed so that 1 leads the row</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">rdx</span> <span class="o">&gt;</span> <span class="n">s1</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">_sr</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">rdx</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
            <span class="n">Linv</span> <span class="o">=</span> <span class="n">swap_columns</span><span class="p">(</span><span class="n">rdx</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">Linv</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 
            <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">f</span><span class="s1">&#39;L</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="s1">&#39;S</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,)</span> 
        <span class="c1"># add sth row to every nonzero row </span>
        <span class="n">row_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimL</span><span class="p">)</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">s1</span> <span class="ow">and</span> <span class="n">S</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="n">cdx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">row_indices</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">_ar</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">L</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">)</span>
            <span class="n">Linv</span> <span class="o">=</span> <span class="n">add_to_column</span><span class="p">(</span><span class="n">Linv</span><span class="p">,</span><span class="n">s1</span><span class="p">,</span><span class="n">idx</span><span class="p">,</span><span class="n">mod</span><span class="o">=</span><span class="n">mod</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">track</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">f</span><span class="s1">&#39;L</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="s1">&#39;S</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,)</span> 

    <span class="k">return</span> <span class="n">L</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">Linv</span></div>

<span class="c1">## Private</span>
<span class="k">def</span> <span class="nf">_coeff</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Computes Zmod2 coordinates for elements of an n-dimensional module</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        dimension of the space, must be nonnegative</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        list of np.arrays with entries in Zmod2</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">addabit</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">temp</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])]</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">addabit</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>


<div class="viewcode-block" id="image_group"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.image_group">[docs]</a><span class="k">def</span> <span class="nf">image_group</span><span class="p">(</span><span class="n">im2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the boundary group</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    im2 : np.array</span>
<span class="sd">        columns form a basis for the boundary group</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : list</span>
<span class="sd">        list of elements of the boundary group</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    image_group() provides a very inefficient method for generating the boundary</span>
<span class="s2">    group and should only be used for small examples.</span>
<span class="s2">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">im2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">image_basis</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">image_group</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">_coeff</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">image_basis</span><span class="p">)):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">matsumreduce</span><span class="p">([</span><span class="n">a</span><span class="o">*</span><span class="n">image_basis</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">alpha</span><span class="p">)])</span>
        <span class="n">image_group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">image_group</span><span class="p">],</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span><span class="p">))</span></div>

<span class="k">def</span> <span class="nf">_coset_reps</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span><span class="n">image_group</span><span class="p">,</span><span class="n">shortest</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private method to compute the coset of the homology group associated to a cycle. </span>
<span class="sd">    Very inefficient so should only be used on small sets.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bs : np.array</span>
<span class="sd">        cycle in chain group</span>
<span class="sd">    image_group : list</span>
<span class="sd">        list of chains in the boundary group</span>
<span class="sd">    shortest : bool, optional</span>
<span class="sd">        restricts the answer to the shortest cycles</span>
<span class="sd">        in the coset</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : list</span>
<span class="sd">        cycles in the coset represented by bs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">image_group</span><span class="p">:</span>
        <span class="n">coset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matsumreduce</span><span class="p">([</span><span class="n">img</span><span class="p">,</span><span class="n">bs</span><span class="p">]))</span>
    <span class="n">coset</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">coset</span><span class="p">,</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">shortest</span><span class="p">:</span>
        <span class="n">mincoset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
        <span class="n">shortest_cycles</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">coset</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="n">mincoset</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">shortest_cycles</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coset</span>

<div class="viewcode-block" id="homology_basis"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.homology_basis">[docs]</a><span class="k">def</span> <span class="nf">homology_basis</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">C</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">shortest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a basis for the kth-homology group with boundary</span>
<span class="sd">    matrices given by bd</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bd : dict</span>
<span class="sd">        dict of k-boundary matrices keyed on k</span>
<span class="sd">    k : int </span>
<span class="sd">        k must be an integer greater than 0</span>
<span class="sd">        bd must have keys for k, and k+1</span>
<span class="sd">    C : None or list</span>
<span class="sd">        optional, list of k-cells used to interpret the generators</span>
<span class="sd">        bd[k] is boundary matrix with rows and columns indexed by</span>
<span class="sd">        k-1 and k cells. C is a list of k chains ordered</span>
<span class="sd">        to match the column index of bd[k] </span>

<span class="sd">    shortest : bool, optional</span>
<span class="sd">        option to look for shortest basis using boundaries</span>
<span class="sd">        only good for very small examples</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : list or dict</span>
<span class="sd">        list of generators as 0-1 tuples, if C then generators will be </span>
<span class="sd">        k-chains</span>
<span class="sd">        if shortest then returns a dictionary of shortest cycles for each coset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L1</span><span class="p">,</span><span class="n">R1</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">L1inv</span> <span class="o">=</span> <span class="n">smith_normal_form_mod2</span><span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="n">L2</span><span class="p">,</span><span class="n">R2</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">L2inv</span> <span class="o">=</span> <span class="n">smith_normal_form_mod2</span><span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="n">rank1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S1</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;rank</span><span class="si">{k}</span><span class="s2"> = </span><span class="si">{rank1}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">rank2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S2</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;rank{k+1} = </span><span class="si">{rank2}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">nullity1</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">rank1</span><span class="p">;</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;nullity</span><span class="si">{k}</span><span class="s2"> = </span><span class="si">{nullity1}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">betti1</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">rank1</span> <span class="o">-</span> <span class="n">rank2</span><span class="p">;</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;betti</span><span class="si">{k}</span><span class="s2"> = </span><span class="si">{betti1}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">cokernel2_dim</span> <span class="o">=</span> <span class="n">S1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rank2</span><span class="p">;</span> <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;cokernel{k+1} dimension = </span><span class="si">{cokernel2_dim}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">ker1</span> <span class="o">=</span> <span class="n">R1</span><span class="p">[:,</span><span class="n">rank1</span><span class="p">:]</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">L2inv</span><span class="p">[:,:</span><span class="n">rank2</span><span class="p">]</span>
    <span class="n">cokernel2</span> <span class="o">=</span> <span class="n">L2inv</span><span class="p">[:,</span><span class="n">rank2</span><span class="p">:]</span>
    <span class="n">cokproj2</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="n">rank2</span><span class="p">:,:]</span>
    
    <span class="n">proj</span> <span class="o">=</span> <span class="n">matmulreduce</span><span class="p">([</span><span class="n">cokernel2</span><span class="p">,</span><span class="n">cokproj2</span><span class="p">,</span><span class="n">ker1</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">_</span><span class="p">,</span><span class="n">proj</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">reduced_row_echelon_form_mod2</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
    <span class="n">proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">proj</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hom basis reps</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">proj</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shortest</span><span class="p">:</span>
        <span class="n">img_group</span> <span class="o">=</span> <span class="n">image_group</span><span class="p">(</span><span class="n">im2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">img_group</span><span class="p">:</span>
            <span class="n">coset</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">bs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">proj</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">C</span><span class="p">:</span>
                    <span class="n">coset</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpret</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">_coset_reps</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span><span class="n">img_group</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coset</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coset_reps</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span><span class="n">img_group</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">C</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">interpret</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">proj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">proj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">C</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">interpret</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="n">proj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proj</span></div>
    
<div class="viewcode-block" id="hypergraph_homology_basis"><a class="viewcode-back" href="../../algorithms/algorithms.html#algorithms.homology_mod2.hypergraph_homology_basis">[docs]</a><span class="k">def</span> <span class="nf">hypergraph_homology_basis</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">shortest</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the kth-homology group mod 2 for the ASC</span>
<span class="sd">    associated with the hypergraph h.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h : hnx.Hypergraph</span>

<span class="sd">    k : int</span>
<span class="sd">        k must be an integer greater than 0</span>

<span class="sd">    shortest : bool, optional</span>
<span class="sd">        option to look for shortest basis using boundaries</span>
<span class="sd">        only good for very small examples   </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : list</span>
<span class="sd">        list of generators as k-chains</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_edge_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">edges</span><span class="p">()])</span>
    <span class="k">if</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">max_edge_size</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;wrong dim&#39;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kchainbasis</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
    <span class="n">bd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">bd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bkMatrix</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>


    <span class="k">return</span> <span class="n">homology_basis</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">shortest</span><span class="o">=</span><span class="n">shortest</span><span class="p">)</span></div>






</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018 Battelle Memorial Institute

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
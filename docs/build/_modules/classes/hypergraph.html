

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>classes.hypergraph &mdash; HyperNetX 0.3.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../_static/copybutton.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> HyperNetX
          

          
            
            <img src="../../_static/hnx_logo_smaller.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installing HyperNetX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../classes/modules.html">Hypergraphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../algorithms/modules.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../drawing/modules.html">Drawing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reports/modules.html">Reports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">HyperNetX</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>classes.hypergraph</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for classes.hypergraph</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright Â© 2018 Battelle Memorial Institute</span>
<span class="c1"># All rights reserved.</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">hypernetx.classes.entity</span> <span class="k">import</span> <span class="n">Entity</span><span class="p">,</span> <span class="n">EntitySet</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">networkx.algorithms</span> <span class="k">import</span> <span class="n">bipartite</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">hypernetx.exception</span> <span class="k">import</span> <span class="n">HyperNetXError</span>



<div class="viewcode-block" id="Hypergraph"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph">[docs]</a><span class="k">class</span> <span class="nc">Hypergraph</span><span class="p">():</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Hypergraph H = (V,E) references a pair of disjoint sets: </span>
<span class="sd">	V = nodes (vertices) and E = (hyper)edges E. </span>

<span class="sd">	The objects in V and E must be distinguishable entities,</span>
<span class="sd">	allowing for multi-edge graphs and inseperable nodes. </span>
<span class="sd">	For example: Let V = {1,2,3} and E = {e1,e2,e3},</span>
<span class="sd">	where e1 = {1,2}, e2 = {1,2}, and e3 = {1,2,3}. </span>
<span class="sd">	The edges e1 and e2 contain the same set of nodes and yet</span>
<span class="sd">	are distinct and must be distinguishable within H.</span>

<span class="sd">	To keep track of the objects in a hypergraph each node and edge is </span>
<span class="sd">	instantiated as an Entity and given an identifier, uid. Since </span>
<span class="sd">	hypergraphs can be quite large, only these identifiers will be used </span>
<span class="sd">	for computation intensive methods, this means the user must take care</span>
<span class="sd">	to keep a one to one correspondence between their set of uids and </span>
<span class="sd">	the objects in their hypergraph. See `Honor System`_ </span>

<span class="sd">	We will create hypergraphs in multiple ways:</span>

<span class="sd">	1. As an empty instance: ::</span>

<span class="sd">		&gt;&gt;&gt; H = hnx.Hypergraph()</span>
<span class="sd">		&gt;&gt;&gt; H.nodes, H.edges</span>
<span class="sd">		({}, {})</span>

<span class="sd">	2. From a dictionary of iterables (elements of iterables must be of type hypernetx.Entity or hashable) ::</span>

<span class="sd">		&gt;&gt;&gt; H = Hypergraph({&#39;a&#39;:[1,2,3],&#39;b&#39;:[4,5,6]})</span>
<span class="sd">		&gt;&gt;&gt; H.nodes, H.edges</span>
<span class="sd">		(EntitySet(_:Nodes,[1, 2, 3, 4, 5, 6],{}), EntitySet(_:Edges,[&#39;b&#39;, &#39;a&#39;],{}))</span>

<span class="sd">	3. From an iterable of iterables: (elements of iterables must be of type hypernetx.Entity or hashable) ::</span>

<span class="sd">		&gt;&gt;&gt; H = Hypergraph([{&#39;a&#39;,&#39;b&#39;},{&#39;b&#39;,&#39;c&#39;},{&#39;a&#39;,&#39;c&#39;,&#39;d&#39;}])</span>
<span class="sd">		&gt;&gt;&gt; H.nodes, H.edges</span>
<span class="sd">		(EntitySet(_:Nodes,[&#39;d&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;],{}),</span>
<span class="sd"> 		 EntitySet(_:Edges,[&#39;_1&#39;, &#39;_2&#39;, &#39;_0&#39;],{}))</span>

<span class="sd">	4. From a hypernetx.EntitySet ::</span>

<span class="sd">		&gt;&gt;&gt; a = Entity(&#39;a&#39;,{1,2}); b = Entity(&#39;b&#39;,{2,3})</span>
<span class="sd">		&gt;&gt;&gt; E = EntitySet(&#39;sample&#39;,elements=[a,b])</span>
<span class="sd">		&gt;&gt;&gt; H = Hypergraph(E)</span>
<span class="sd">		&gt;&gt;&gt; H.nodes, H.edges</span>
<span class="sd">		(EntitySet(_:Nodes,[1, 2, 3],{}), EntitySet(_:Edges,[&#39;b&#39;, &#39;a&#39;],{}))</span>

<span class="sd">	5. From a networkx bipartite graph using :code:`from_bipartite()`:</span>

<span class="sd">		&gt;&gt;&gt; import networkx as nx</span>
<span class="sd">		&gt;&gt;&gt; B = nx.Graph()</span>
<span class="sd">		&gt;&gt;&gt; B.add_nodes_from([1, 2, 3, 4], bipartite=0)</span>
<span class="sd">		&gt;&gt;&gt; B.add_nodes_from([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], bipartite=1)</span>
<span class="sd">		&gt;&gt;&gt; B.add_edges_from([(1, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;b&#39;), (2, &#39;c&#39;), (3, &#39;c&#39;), (4, &#39;a&#39;)])</span>
<span class="sd">		&gt;&gt;&gt; H = Hypergraph.from_bipartite(B)</span>
<span class="sd">		&gt;&gt;&gt; H.nodes, H.edges</span>
<span class="sd">		(EntitySet(_:Nodes,[1, 2, 3, 4],{}), EntitySet(_:Edges,[&#39;b&#39;, &#39;c&#39;, &#39;a&#39;],{}))</span>

<span class="sd">	Parameters</span>
<span class="sd">	----------</span>
<span class="sd">	setsystem : EntitySet or dictionary or iterable of hashables or Entities, optional, default: None</span>
<span class="sd">		If not an EntitySet then setsystem must be acceptable as elements to an EntitySet</span>

<span class="sd">	name : hashable, optional, default: None</span>

<span class="sd">	&quot;&quot;&quot;</span>


	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">setsystem</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">):</span> 

		<span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

		<span class="c1">##### Check setsystem type and change into an EntitySet before constructing hypergraph:</span>

		<span class="k">if</span> <span class="ow">not</span> <span class="n">setsystem</span><span class="p">:</span>
			<span class="n">setsystem</span> <span class="o">=</span> <span class="n">EntitySet</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="n">elements</span><span class="o">=</span><span class="p">[])</span>

		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setsystem</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
			<span class="c1">### Must be a dictionary with values equal to iterables of Entities and hashables.</span>
			<span class="c1">### Keys will be uids for new edges and values of the dictionary will generate the nodes.</span>
			<span class="n">setsystem</span> <span class="o">=</span> <span class="n">EntitySet</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="n">setsystem</span><span class="p">)</span>

		<span class="c1">### If no ids are given, return default ids indexed by position in iterator</span>
		<span class="c1">### This should be an iterable of sets</span>
		<span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setsystem</span><span class="p">,</span> <span class="n">EntitySet</span><span class="p">):</span>
			<span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">setsystem</span><span class="p">))]</span>
			<span class="n">setsystem</span> <span class="o">=</span> <span class="n">EntitySet</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">setsystem</span><span class="p">)))</span>

		<span class="n">_reg</span> <span class="o">=</span> <span class="n">setsystem</span><span class="o">.</span><span class="n">registry</span>
		<span class="n">_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">Entity</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="o">**</span><span class="n">_reg</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_reg</span> <span class="p">}</span>
		<span class="n">_elements</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span> <span class="p">:</span> <span class="n">_nodes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">setsystem</span><span class="p">[</span><span class="n">j</span><span class="p">]}</span> 
						<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">setsystem</span><span class="p">}</span>
		<span class="n">_edges</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="n">Entity</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> 
					<span class="n">elements</span> <span class="o">=</span> <span class="n">_elements</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> 
					<span class="o">**</span><span class="n">setsystem</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">setsystem</span><span class="p">}</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="n">EntitySet</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{self.name}</span><span class="s1">:Edges&#39;</span><span class="p">,</span> 
						<span class="n">elements</span> <span class="o">=</span> <span class="n">_edges</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="o">**</span><span class="n">setsystem</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">EntitySet</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{self.name}</span><span class="s1">:Nodes&#39;</span><span class="p">,</span> 
						<span class="n">elements</span> <span class="o">=</span> <span class="n">_nodes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>


	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Dictionary of EntitySet of (hyper)edges</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Dictionary of EntitySet of nodes</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span>


	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">incidence_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Dictionary keyed by edge uids with values the uids of nodes in each edge</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">incidence_dict</span>

	<span class="nd">@property</span>
	<span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Tuple giving (number of nodes, number of edgess)</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		String representation of hypergraph</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">f</span><span class="s1">&#39;Hypergraph(</span><span class="si">{self.edges.elements}</span><span class="s1">,name=</span><span class="si">{self.name}</span><span class="s1">)&#39;</span>

	<span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		String representation of hypergraph</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">f</span><span class="s1">&#39;Hypergraph(</span><span class="si">{self.edges.elements}</span><span class="s1">,name=</span><span class="si">{self.name}</span><span class="s1">)&#39;</span>

	<span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Number of nodes</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Determine if two hypergraphs are equal.</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		other : Hypergraph</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		boolean : boolean </span>
<span class="sd">		</span>
<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Two Hypergraphs are equal if they have the same name and</span>
<span class="sd">		are generated by the same EntitySet(=self.edges). If one of them does not</span>
<span class="sd">		have a name only the EntitySets are checked.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="n">Hypergraph</span><span class="p">)</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">False</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">incidence_dict</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">incidence_dict</span>

	<span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Iterate over the nodes of the hypergraph</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">item</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns boolean indicating if item is in self.nodes</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		item : hashable or Entity</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">uid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>

	<span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return the neighbors of node</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		node : Entity or hashable</span>
<span class="sd">			If hashable, then must be uid of node in hypergraph</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		neighbors(node) : iterator</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

<div class="viewcode-block" id="Hypergraph.s_degree"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.s_degree">[docs]</a>	<span class="k">def</span> <span class="nf">s_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return the degree of a node in H when restricted to edges</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		node : Entity or hashable</span>
<span class="sd">			If hashable, then must be uid of node in hypergraph</span>

<span class="sd">		s : positive integer, optional, default: 1</span>

<span class="sd">		edges : iterable of edge.uids, optional, default: None</span>

<span class="sd">		Returns</span>
<span class="sd">		------- </span>
<span class="sd">		s_degree : int</span>
<span class="sd">			The degree of a node in the subgraph induced by edges</span>
<span class="sd">			if edges = None return the s-degree of the node</span>

<span class="sd">		Note</span>
<span class="sd">		----</span>
<span class="sd">		The :term:`s-degree` of a node is the number of edges of size</span>
<span class="sd">		at least s that contain the node. </span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.degree"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.degree">[docs]</a>	<span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return the degree of a node in H</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		node : node.uid</span>

<span class="sd">		s : positive integer, optional</span>

<span class="sd">		edges : iterable of edge.uids, optional</span>


<span class="sd">		Returns</span>
<span class="sd">		------- </span>
<span class="sd">			The degree of a node in the subgraph induced by edges</span>
<span class="sd">			if edges = None return the s-degree of the node</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">			The s-degree of a node is the number of edges of size</span>
<span class="sd">			at least s that contain the node.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">memberships</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">memberships</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">edges</span><span class="p">:</span>
			<span class="n">memberships</span> <span class="o">=</span> <span class="n">memberships</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">s</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">memberships</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">])</span><span class="o">&gt;=</span><span class="n">s</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">memberships</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.number_of_nodes"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.number_of_nodes">[docs]</a>	<span class="k">def</span> <span class="nf">number_of_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nodeset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		The number of nodes in nodeset belonging to hypergraph.</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		nodeset : an interable of Entities, optional, default: None</span>
<span class="sd">			If None, then return the number of nodes in hypergraph.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		number_of_nodes : int</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">nodeset</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodeset</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.number_of_edges"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.number_of_edges">[docs]</a>	<span class="k">def</span> <span class="nf">number_of_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">edgeset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		The number of edges in edgeset belonging to hypergraph.</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		edgeset : an interable of Entities, optional, default: None</span>
<span class="sd">			If None, then return the number of edges in hypergraph.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		number_of_edges : int</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">edgeset</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.order"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.order">[docs]</a>	<span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		The number of nodes in hypergraph.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		order : int</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.size"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.size">[docs]</a>	<span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">edge</span><span class="p">,</span><span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		The number of nodes in nodes that belong to edge.</span>
<span class="sd">		If nodes=None, returns the number of nodes in edge.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		edge : hashable</span>
<span class="sd">			The uid of an edge in the hypergraph</span>

<span class="sd">		nodes : iterable, optional, default: hypergraph.nodes.uidset</span>
<span class="sd">			An iterable of uids for nodes in hypergraph.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		size : int</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">nodes</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">uidset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nodes</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">])</span></div>

<div class="viewcode-block" id="Hypergraph.dim"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.dim">[docs]</a>	<span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">edge</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Same as size(edge)-1.</span>
<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Hypergraph.neighbors"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.neighbors">[docs]</a>	<span class="k">def</span> <span class="nf">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		The nodes in hypergraph which share an :term:`s-edge` with node.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		node : hashable</span>
<span class="sd">			uid for a node in hypergraph</span>

<span class="sd">		s : int, optional, default : 2</span>
<span class="sd">			The desired size of the edge connecting node to its neighbors</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		neighbors : iterator</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">memberships</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">memberships</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">uidset</span><span class="p">)</span>
		<span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">memberships</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="o">&gt;=</span><span class="n">s</span><span class="p">]</span>
		<span class="n">neigh</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
			<span class="n">neigh</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">uidset</span><span class="p">)</span>
		<span class="n">neigh</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span></div>


<div class="viewcode-block" id="Hypergraph.remove_node"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.remove_node">[docs]</a>	<span class="k">def</span> <span class="nf">remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Removes node from edges and deletes reference in hypergraph nodes</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		node : hashable or Entity</span>
<span class="sd">			a node in hypergraph</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		hypergraph : Hypergraph</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
				<span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">memberships</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Hypergraph.remove_nodes"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.remove_nodes">[docs]</a>	<span class="k">def</span> <span class="nf">remove_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node_set</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Removes nodes from edges and deletes references in hypergraph nodes</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		node_set : an iterable of hashables or Entities</span>
<span class="sd">			Nodes in hypergraph</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		hypergraph : Hypergraph</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_set</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span></div>

	<span class="k">def</span> <span class="nf">_add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nodes</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Private helper method instantiates new nodes when edges added to hypergraph. </span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		nodes : iterable of hashables or Entities</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">:</span>
				<span class="k">raise</span> <span class="n">HyperNetxError</span><span class="p">(</span><span class="s2">&quot;Node already an edge.&quot;</span><span class="p">)</span>
			<span class="k">elif</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>  
			<span class="k">elif</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">:</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Entity</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="o">**</span><span class="n">node</span><span class="o">.</span><span class="n">properties</span><span class="p">))</span> 
				<span class="k">else</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Entity</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> 

<div class="viewcode-block" id="Hypergraph.add_edge"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.add_edge">[docs]</a>	<span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">edge</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Adds a single edge to hypergraph.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		edge : hashable or Entity</span>
<span class="sd">			If hashable the edge returned will be empty.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		hypergraph : Hypergraph</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		When adding an edge to a hypergraph children must be removed </span>
<span class="sd">		so that nodes do not have elements.</span>
<span class="sd">		Each node (element of edge) must be instantiated as a node, </span>
<span class="sd">		making sure its uid isn&#39;t already present in the self.</span>
<span class="sd">		If an added edge contains nodes that cannot be added to hypergraph</span>
<span class="sd">		then an error will be thrown.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot add edge. Edge already in hypergraph&quot;</span><span class="p">)</span>  
		<span class="k">elif</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot add edge. Edge is already a Node&quot;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_add_nodes_from</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">elements</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Entity</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span>
					<span class="n">elements</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">],</span> <span class="o">**</span><span class="n">edge</span><span class="o">.</span><span class="n">properties</span><span class="p">))</span>
				<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">memberships</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">uid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">uid</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Entity</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="o">**</span><span class="n">edge</span><span class="o">.</span><span class="n">properties</span><span class="p">))</span>		
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Entity</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>  <span class="c1">### this generates an empty edge</span>
		<span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Hypergraph.add_edges_from"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.add_edges_from">[docs]</a>	<span class="k">def</span> <span class="nf">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">edge_set</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Add edges to hypergraph.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		edge_set : iterable of hashables or Entities</span>
<span class="sd">			For hashables the edges returned will be empty.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		hypergraph : Hypergraph</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_set</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="Hypergraph.add_node_to_edge"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.add_node_to_edge">[docs]</a>	<span class="k">def</span> <span class="nf">add_node_to_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">edge</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Adds node to an edge in hypergraph edges</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		node: hashable or Entity </span>
<span class="sd">			If Entity, only uid and properties will be used.</span>
<span class="sd">			If uid is already in nodes then the known node will </span>
<span class="sd">			be used</span>

<span class="sd">		edge: uid of edge or edge, must belong to self.edges</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		hypergraph : Hypergraph</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
				<span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">:</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
					<span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
					<span class="n">node</span> <span class="o">=</span> <span class="n">Entity</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">node</span> <span class="o">=</span> <span class="n">Entity</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="o">**</span><span class="n">node</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span></div>



<div class="viewcode-block" id="Hypergraph.remove_edge"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.remove_edge">[docs]</a>	<span class="k">def</span> <span class="nf">remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">edge</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Removes a single edge from hypergraph.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		edge : hashable or Entity</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		hypergraph : Hypergraph</span>
<span class="sd">		</span>
<span class="sd">		Notes</span>
<span class="sd">		-----</span>

<span class="sd">		Deletes reference to edge from all of its nodes. </span>
<span class="sd">		If any of its nodes do not belong to any other edges</span>
<span class="sd">		the node is dropped from self.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
				<span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">edge</span><span class="o">.</span><span class="n">uidset</span><span class="p">:</span>
				<span class="n">edge</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">_memberships</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Hypergraph.remove_edges"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.remove_edges">[docs]</a>	<span class="k">def</span> <span class="nf">remove_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">edge_set</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Removes edges from hypergraph.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		edge_set : iterable of hashables or Entities</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		hypergraph : Hypergraph</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_set</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Hypergraph.incidence_matrix"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.incidence_matrix">[docs]</a>	<span class="k">def</span> <span class="nf">incidence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An incidence matrix for the hypergraph indexed by nodes x edges.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sparse : boolean, optional, default: True</span>

<span class="sd">        index : boolean, optional, default False</span>
<span class="sd">            If True return will include a dictionary of node uid : row number</span>
<span class="sd">            and edge uid : column number</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        incidence_matrix : scipy.sparse.csr.csr_matrix or np.ndarray</span>

<span class="sd">        row dictionary : dict</span>
<span class="sd">            Dictionary identifying rows with nodes</span>

<span class="sd">        column dictionary : dict</span>
<span class="sd">            Dictionary identifying columns with edges</span>

<span class="sd">        &quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">sparse</span><span class="p">,</span><span class="n">index</span><span class="p">)</span></div>


	<span class="k">def</span> <span class="nf">__incidence_to_adjacency</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;	</span>
<span class="sd">		Helper method to obtain adjacency matrix from incidence matrix.</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		M : scipy.sparse.csr.csr_matrix</span>

<span class="sd">		s : int, optional, default: 1</span>

<span class="sd">		weighted : boolean, optional, default: True</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		a matrix : scipy.sparse.csr.csr_matrix</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">A</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
		<span class="n">A</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">weighted</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span>
		<span class="k">return</span> <span class="n">A</span>


<div class="viewcode-block" id="Hypergraph.adjacency_matrix"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.adjacency_matrix">[docs]</a>	<span class="k">def</span> <span class="nf">adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		The sparse weighted :term:`s-adjacency matrix`</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		s : int, optional, default: 1</span>

<span class="sd">		index: boolean, optional, default: False</span>
<span class="sd">			if True, will return a rowdict of row to node uid</span>

<span class="sd">		weighted: boolean, optional, default: True</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		adjacency_matrix : scipy.sparse.csr.csr_matrix</span>

<span class="sd">		row dictionary : dict</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		If weighted is True each off diagonal cell will equal the number </span>
<span class="sd">		of edges shared by the nodes indexing the row and column if that number is </span>
<span class="sd">		greater than s, otherwise the cell will equal 0. If weighted is False, the off </span>
<span class="sd">		diagonal cell will equal 1 if the nodes indexed by the row and column share at</span>
<span class="sd">		least s edges and 0 otherwise.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">index</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">Hypergraph</span><span class="o">.</span><span class="n">__incidence_to_adjacency</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">),</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">Hypergraph</span><span class="o">.</span><span class="n">__incidence_to_adjacency</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.edge_adjacency_matrix"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.edge_adjacency_matrix">[docs]</a>	<span class="k">def</span> <span class="nf">edge_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		The sparse weighted :term:`s-adjacency matrix` for the dual hypergraph.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		s : int, optional, default: 1</span>

<span class="sd">		index: boolean, optional, default: False</span>
<span class="sd">			if True, will return a coldict of column to edge uid</span>

<span class="sd">		weighted: boolean, optional, default: True</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		edge_adjacency_matrix : scipy.sparse.csr.csr_matrix</span>

<span class="sd">		column dictionary : dict</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		This is also the adjacency matrix for the line graph.</span>
<span class="sd">		Two edges are s-adjacent if they share at least s nodes.</span>
<span class="sd">		If index=True, returns a dictionary column_index:edge_uid</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">index</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">Hypergraph</span><span class="o">.</span><span class="n">__incidence_to_adjacency</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">),</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">Hypergraph</span><span class="o">.</span><span class="n">__incidence_to_adjacency</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">)</span></div>


<div class="viewcode-block" id="Hypergraph.auxiliary_matrix"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.auxiliary_matrix">[docs]</a>	<span class="k">def</span> <span class="nf">auxiliary_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		The sparse unweighted :term:`s-auxiliary matrix` for hypergraph</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		s : int</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		auxiliary_matrix : scipy.sparse.csr.csr_matrix</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Creates subgraph by restricting to edges of cardinality at least s.</span>
<span class="sd">		Returns the unweighted s-edge adjacency matrix for the subgraph.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span><span class="n">s</span><span class="p">]</span>
		<span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">restrict_to_edges</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">edge_adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">weighted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.bipartite"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.bipartite">[docs]</a>	<span class="k">def</span> <span class="nf">bipartite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node_label</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">edge_label</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Constructs the networkX bipartite graph associated to hypergraph.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		node_label : hashable</span>

<span class="sd">		edge_label : hashable</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		bipartite : nx.Graph() </span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Creates a bipartite networkx graph from hypergraph.</span>
<span class="sd">		The nodes and (hyper)edges of hypergraph become the nodes of bipartite graph.</span>
<span class="sd">		For every (hyper)edge e in the hypergraph and node n in e there is an edge (n,e)</span>
<span class="sd">		in the graph.</span>
<span class="sd">		The labels indicate the bipartite partition to use when defining the graph.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">B</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
		<span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
		<span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
		<span class="n">B</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">bipartite</span><span class="o">=</span><span class="n">edge_label</span><span class="p">)</span>
		<span class="n">B</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">bipartite</span><span class="o">=</span><span class="n">node_label</span><span class="p">)</span>
		<span class="n">B</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">E</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">V</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">E</span><span class="p">[</span><span class="n">e</span><span class="p">]])</span>
		<span class="k">return</span> <span class="n">B</span></div>

<div class="viewcode-block" id="Hypergraph.dual"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.dual">[docs]</a>	<span class="k">def</span> <span class="nf">dual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Constructs a new hypergraph with roles of edges and nodes of hypergraph reversed.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		name : hashable</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		dual : hypergraph</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>
		<span class="n">E</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">incidence_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
				<span class="n">E</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.collapse_edges"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.collapse_edges">[docs]</a>	<span class="k">def</span> <span class="nf">collapse_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_reps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Constructs a new hypergraph gotten by identifying edges containing the same nodes</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		name : hashable, optional, default: None</span>

<span class="sd">		use_reps : boolean, optional, default: False</span>
<span class="sd">			Choose a single edge from the collapsed edges as uid for the new edge, otherwise uses</span>
<span class="sd">			a frozen set of the uids of edges in the equivalence class</span>

<span class="sd">		return_counts: boolean, optional, default: True</span>
<span class="sd">			if use_reps is True the new edges are keyed by a tuple of the rep and the count</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		new hypergraph : Hypergraph</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Two edges are identified if their respective elements are the same. </span>
<span class="sd">		Using this as an equivalence relation, the uids of the edges are partitioned into</span>
<span class="sd">		equivalence classes. A frozenset of equivalent edges serves as uid</span>
<span class="sd">		for each edge entity.</span>

<span class="sd">		If use_reps=True the frozen sets will be replaced with a representative</span>
<span class="sd">		from the equivalence classes.</span>

<span class="sd">		Example</span>
<span class="sd">		-------</span>

<span class="sd">			&gt;&gt;&gt; h = Hypergraph(EntitySet(&#39;example&#39;,elements=[Entity(&#39;E1&#39;, [&#39;a&#39;,&#39;b&#39;]),Entity(&#39;E2&#39;,[&#39;a&#39;,&#39;b&#39;])]))</span>
<span class="sd">			&gt;&gt;&gt; h.incidence_dict</span>
<span class="sd">			{&#39;E1&#39;: {&#39;a&#39;, &#39;b&#39;}, &#39;E2&#39;: {&#39;a&#39;, &#39;b&#39;}}</span>
<span class="sd">			&gt;&gt;&gt; h.collapse_edges().incidence_dict</span>
<span class="sd">			{frozenset({&#39;E1&#39;, &#39;E2&#39;}): {&#39;a&#39;, &#39;b&#39;}}</span>
<span class="sd">			&gt;&gt;&gt; h.collapse_edges(use_reps=True).incidence_dict</span>
<span class="sd">			{(&#39;E1&#39;, 2): {&#39;a&#39;, &#39;b&#39;}}</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">collapse_identical_elements</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="n">use_reps</span><span class="o">=</span><span class="n">use_reps</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="n">return_counts</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.collapse_nodes"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.collapse_nodes">[docs]</a>	<span class="k">def</span> <span class="nf">collapse_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_reps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Constructs a new hypergraph gotten by identifying nodes contained by the same edges</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------        </span>
<span class="sd">		use_reps : boolean, optional, default: False</span>
<span class="sd">			Choose a single element from the collapsed nodes as uid for the new node, otherwise uses </span>
<span class="sd">			a frozen set of the uids of nodes in the equivalence class</span>

<span class="sd">		return_counts: if use_reps is True the new nodes have uids given by a tuple of the rep</span>
<span class="sd">			and the count</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		new hypergraph : Hypergraph</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Two nodes are identified if their respective memberships are the same. </span>
<span class="sd">		Using this as an equivalence relation, the uids of the nodes are partitioned into</span>
<span class="sd">		equivalence classes. A frozenset of equivalent nodes serves as uid</span>
<span class="sd">		for each node entity.</span>

<span class="sd">		Example</span>
<span class="sd">		-------</span>

<span class="sd">			&gt;&gt;&gt; h = Hypergraph(EntitySet(&#39;example&#39;,elements=[Entity(&#39;E1&#39;, [&#39;a&#39;,&#39;b&#39;]),Entity(&#39;E2&#39;,[&#39;a&#39;,&#39;b&#39;])]))</span>
<span class="sd">			&gt;&gt;&gt; h.incidence_dict</span>
<span class="sd">			{&#39;E1&#39;: {&#39;a&#39;, &#39;b&#39;}, &#39;E2&#39;: {&#39;a&#39;, &#39;b&#39;}}</span>
<span class="sd">			&gt;&gt;&gt; h.collapse_nodes().incidence_dict</span>
<span class="sd">			{&#39;E1&#39;: {frozenset({&#39;a&#39;, &#39;b&#39;})}, &#39;E2&#39;: {frozenset({&#39;a&#39;, &#39;b&#39;})}}</span>
<span class="sd">			&gt;&gt;&gt; h.collapse_nodes(use_reps=True).incidence_dict</span>
<span class="sd">			{&#39;E1&#39;: {(&#39;a&#39;, 2)}, &#39;E2&#39;: {(&#39;a&#39;, 2)}}</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">collapse_identical_elements</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="n">use_reps</span><span class="o">=</span><span class="n">use_reps</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="n">return_counts</span><span class="p">),</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span></div>

<div class="viewcode-block" id="Hypergraph.collapse_nodes_and_edges"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.collapse_nodes_and_edges">[docs]</a>	<span class="k">def</span> <span class="nf">collapse_nodes_and_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_reps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a new hypergraph by collapsing nodes and edges.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>

<span class="sd">		use_reps: boolean, optional, default: False</span>
<span class="sd">			Choose a single element from the collapsed elements as a representative</span>

<span class="sd">		return_counts: boolean, optional, default: True</span>
<span class="sd">			if use_reps is True the new elements are keyed by a tuple of the rep</span>
<span class="sd">			and the count</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		new hypergraph : Hypergraph</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Collapses the Nodes and Edges EntitySets. Two nodes(edges) are duplicates</span>
<span class="sd">		if their respective memberships(elements) are the same. Using this as an</span>
<span class="sd">		equivalence relation, the uids of the nodes(edges) are partitioned into</span>
<span class="sd">		equivalence classes. A frozenset of equivalent nodes(edges) serves as unique id</span>
<span class="sd">		for each node(edge) entity.</span>

<span class="sd">		Example</span>
<span class="sd">		-------</span>

<span class="sd">			&gt;&gt;&gt; h = Hypergraph(EntitySet(&#39;example&#39;,elements=[Entity(&#39;E1&#39;, [&#39;a&#39;,&#39;b&#39;]),Entity(&#39;E2&#39;,[&#39;a&#39;,&#39;b&#39;])]))</span>
<span class="sd">			&gt;&gt;&gt; h.incidence_dict</span>
<span class="sd">			{&#39;E1&#39;: {&#39;a&#39;, &#39;b&#39;}, &#39;E2&#39;: {&#39;a&#39;, &#39;b&#39;}}</span>
<span class="sd">			&gt;&gt;&gt; h.collapse_nodes_and_edges().incidence_dict</span>
<span class="sd">			{frozenset({&#39;E1&#39;, &#39;E2&#39;}): {frozenset({&#39;a&#39;, &#39;b&#39;})}}</span>
<span class="sd">			&gt;&gt;&gt; h.collapse_nodes_and_edges(use_reps=True).incidence_dict</span>
<span class="sd">			{(&#39;E1&#39;, 2): {(&#39;a&#39;, 2)}}</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span><span class="n">use_reps</span><span class="o">=</span><span class="n">use_reps</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="n">return_counts</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">temp</span><span class="o">.</span><span class="n">collapse_edges</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span><span class="n">use_reps</span><span class="o">=</span><span class="n">use_reps</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="n">return_counts</span><span class="p">)</span></div>
	
<div class="viewcode-block" id="Hypergraph.restrict_to_edges"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.restrict_to_edges">[docs]</a>	<span class="k">def</span> <span class="nf">restrict_to_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">edgeset</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Constructs a hypergraph using a subset of the edges in hypergraph</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		edgeset: iterable of hashables or Entities</span>
<span class="sd">			A subset of elements of the hypergraph edges</span>

<span class="sd">		name: str, optional, default: None</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		new hypergraph : Hypergraph</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
		<span class="k">return</span> <span class="n">Hypergraph</span><span class="p">({</span><span class="n">e</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="p">},</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Hypergraph.restrict_to_nodes"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.restrict_to_nodes">[docs]</a>	<span class="k">def</span> <span class="nf">restrict_to_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nodeset</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Constructs a new hypergraph by restricting the edges in the hypergraph to</span>
<span class="sd">		the nodes referenced by nodeset.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		nodeset: iterable of hashables</span>
<span class="sd">			References a subset of elements of self.nodes</span>

<span class="sd">		name: string, optional, default: None</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		new hypergraph : Hypergraph</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">memberships</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeset</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
				<span class="n">memberships</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">memberships</span><span class="p">))</span>
		<span class="n">newedgeset</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">memberships</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
				<span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">uidset</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nodeset</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">temp</span><span class="p">:</span>
					<span class="n">newedgeset</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">Entity</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">temp</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="n">newedgeset</span><span class="p">,</span><span class="n">name</span><span class="p">)</span> </div>

<div class="viewcode-block" id="Hypergraph.toplexes"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.toplexes">[docs]</a>	<span class="k">def</span> <span class="nf">toplexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">collapse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">use_reps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> 
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a :term:`simple hypergraph` corresponding to self.</span>

<span class="sd">		Warning</span>
<span class="sd">		------- </span>
<span class="sd">		Collapsing a hypergraph can take a long time. It may be preferable to collapse the graph first and</span>
<span class="sd">		pickle it, then apply the toplexes method separately.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		name: str, optional, default: None</span>

<span class="sd">		collapse: boolean, optional, default: False</span>
<span class="sd">			Should the hypergraph be collapsed? This would preserve a link between duplicate maximal sets.</span>
<span class="sd">			If False then only one of these sets will be used and uniqueness will be up to sets of equal size.</span>

<span class="sd">		use_reps: boolean, optional, default: False</span>
<span class="sd">			If collapse=True then each toplex will be named by a representative of the set of</span>
<span class="sd">			equivalent edges, default is False (see collapse_edges).</span>

<span class="sd">		return_counts: boolean, optional, default: True</span>
<span class="sd">			If collapse=True then each toplex will be named by a tuple of the representative</span>
<span class="sd">			of the set of equivalent edges and their count</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">collapse</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>  <span class="c1">### TODO: Determine how big is too big.</span>
				<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Collapsing a hypergraph can take a long time. It may be preferable to collapse the graph first and pickle it then apply the toplex method separately.&#39;</span><span class="p">)</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_edges</span><span class="p">(</span><span class="n">use_reps</span><span class="o">=</span><span class="n">use_reps</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="n">return_counts</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span>
		<span class="n">thdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
			<span class="n">thdict</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">uidset</span>
		<span class="n">tops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">temp</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span> 
			<span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
			<span class="n">old_tops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">top</span> <span class="ow">in</span> <span class="n">old_tops</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">thdict</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">thdict</span><span class="p">[</span><span class="n">top</span><span class="p">]):</span>
					<span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
					<span class="k">break</span>
				<span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">thdict</span><span class="p">[</span><span class="n">top</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">thdict</span><span class="p">[</span><span class="n">e</span><span class="p">]):</span>
					<span class="k">del</span> <span class="n">tops</span><span class="p">[</span><span class="n">top</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
				<span class="n">tops</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">e</span> <span class="p">:</span> <span class="n">thdict</span><span class="p">[</span><span class="n">e</span><span class="p">]})</span>
		<span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="n">tops</span><span class="p">,</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.is_connected"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.is_connected">[docs]</a>	<span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Determines if hypergraph is :term:`s-connected &lt;s-connected, s-node-connected&gt;`.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		s: int, optional, default: 1</span>

<span class="sd">		edges: boolean, optional, default: False</span>
<span class="sd">			If True, will determine if s-edge-connected.</span>
<span class="sd">			For s=1 s-edge-connected is the same as s-connected. </span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		is_connected : boolean</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>

<span class="sd">		A hypergraph is s node connected if for any two nodes v0,vn</span>
<span class="sd">		there exists a sequence of nodes v0,v1,v2,...,v(n-1),vn</span>
<span class="sd">		such that every consecutive pair of nodes v(i),v(i+1) </span>
<span class="sd">		share at least s edges.</span>

<span class="sd">		A hypergraph is s edge connected if for any two edges e0,en</span>
<span class="sd">		there exists a sequence of edges e0,e1,e2,...,e(n-1),en</span>
<span class="sd">		such that every consecutive pair of edges e(i),e(i+1)</span>
<span class="sd">		share at least s nodes.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">edges</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
		<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.singletons"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.singletons">[docs]</a>	<span class="k">def</span> <span class="nf">singletons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a list of singleton edges. A singleton edge is an edge of </span>
<span class="sd">		size 1 with a node of degree 1.</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		singletons : list</span>
<span class="sd">			A list of edge uids.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">M</span><span class="p">,</span><span class="n">r_</span><span class="p">,</span><span class="n">cdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1">## which axis has fewest members? if 1 then columns</span>
		<span class="n">cols</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="c1">## we add down the row index if there are fewer columns</span>
		<span class="n">edges_to_discard</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
		<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">shape</span><span class="p">[(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">]):</span> <span class="c1">## index along opposite axis</span>
			<span class="k">if</span> <span class="n">cols</span><span class="p">[</span><span class="n">idx</span><span class="o">*</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">*</span><span class="p">((</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="c1"># then see if the singleton entry in that column is also singleton in its row</span>
				<span class="c1"># find the entry</span>
				<span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
					<span class="c1"># and get its sum</span>
					<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">getrow</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
					<span class="c1"># if this is also 1 then the entry in r,c represents a singleton</span>
					<span class="c1"># so we want to change that entry to 0 and remove the row.</span>
					<span class="c1"># this means we want to remove the edge corresponding to c</span>
					<span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
						<span class="n">edges_to_discard</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdict</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
				<span class="k">else</span><span class="p">:</span> <span class="c1">#switch the role of r and c</span>
					<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">getrow</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
					<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
					<span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
						<span class="n">edges_to_discard</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdict</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">edges_to_discard</span>	 </div>

<div class="viewcode-block" id="Hypergraph.remove_singletons"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.remove_singletons">[docs]</a>	<span class="k">def</span> <span class="nf">remove_singletons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Constructs clone of hypergraph with singleton edges removed.</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		name: str, optional, default: None</span>
<span class="sd">		</span>
<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		new hypergraph : Hypergraph</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">singles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">singletons</span><span class="p">()</span>
		<span class="n">edgeset</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">singles</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">Hypergraph</span><span class="p">({</span><span class="n">e</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="p">},</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.s_connected_components"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.s_connected_components">[docs]</a>	<span class="k">def</span> <span class="nf">s_connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>   
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a generator for the :term:`s-edge-connected components &lt;s-edge-connected component&gt;` </span>
<span class="sd">		or the :term:`s-node-connected components &lt;s-connected component, s-node-connected component&gt;` </span>
<span class="sd">		of the hypergraph. </span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		s: int, optional, default: 1 </span>

<span class="sd">		edges: boolean, optional, default: True</span>
<span class="sd">			If True will return edge components, if False will return node components</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		s_connected_components: iterator </span>
<span class="sd">			Iterator returns sets of uids of the edges (or nodes) in the s-edge(node) components of hypergraph. </span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		If edges=True, this method returns the s-edge-connected components as </span>
<span class="sd">		lists of lists of edge uids.</span>
<span class="sd">		An s-edge-component has the property that for any two edges e1 and e2</span>
<span class="sd">		there is a sequence of edges starting with e1 and ending with e2</span>
<span class="sd">		such that pairwise adjacent edges in the sequence intersect in at least </span>
<span class="sd">		s nodes. If s=1 these are the path components of the hypergraph.</span>

<span class="sd">		If edges=False this method returns s-node-connected components.</span>
<span class="sd">		A list of sets of uids of the nodes which are s-walk connected. </span>
<span class="sd">		Two nodes v1 and v2 are s-walk-connected if there is a </span>
<span class="sd">		sequence of nodes starting with v1 and ending with v2 such that pairwise </span>
<span class="sd">		adjacent nodes in the sequence share s edges. If s=1 these are the</span>
<span class="sd">		path components of the hypergraph. </span>

<span class="sd">		Example		</span>
<span class="sd">		-------</span>
<span class="sd">			&gt;&gt;&gt; S = {&#39;A&#39;:{1,2,3},&#39;B&#39;:{2,3,4},&#39;C&#39;:{5,6},&#39;D&#39;:{6}}</span>
<span class="sd">			&gt;&gt;&gt; H = Hypergraph(S)</span>

<span class="sd">			&gt;&gt;&gt; list(H.s_components(edges=True))</span>
<span class="sd">			[{&#39;C&#39;, &#39;D&#39;}, {&#39;A&#39;, &#39;B&#39;}]</span>
<span class="sd">			&gt;&gt;&gt; list(H.s_components(edges=False))</span>
<span class="sd">			[{1, 2, 3, 4}, {5, 6}]</span>

<span class="sd">		&quot;&quot;&quot;</span>

		<span class="k">if</span> <span class="n">edges</span><span class="p">:</span>
			<span class="n">A</span><span class="p">,</span><span class="n">coldict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
			<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
				<span class="k">yield</span> <span class="p">{</span><span class="n">coldict</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c</span><span class="p">}</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">A</span><span class="p">,</span><span class="n">rowdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
			<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
				<span class="k">yield</span> <span class="p">{</span><span class="n">rowdict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">c</span><span class="p">}</span></div>

<div class="viewcode-block" id="Hypergraph.s_component_subgraphs"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.s_component_subgraphs">[docs]</a>	<span class="k">def</span> <span class="nf">s_component_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns a generator for the induced subgraphs of s_connected components.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		s : int, optional, default: 1</span>

<span class="sd">		edges: boolean, optional, edges=False</span>
<span class="sd">			Determines if edge or node components are desired. Returns </span>
<span class="sd">			subgraphs equal to the hypergraph restricted to each set of nodes(edges) in the </span>
<span class="sd">			s-connected components or s-edge-connected components</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		s_component_subgraphs : iterator</span>
<span class="sd">			Iterator returns subgraphs generated by the edges (or nodes) in the </span>
<span class="sd">			s-edge(node) components of hypergraph. </span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_components</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)):</span>
			<span class="k">if</span> <span class="n">edges</span><span class="p">:</span>
				<span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">restrict_to_edges</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{self.name}</span><span class="s1">:</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">restrict_to_nodes</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{self.name}</span><span class="s1">:</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.s_components"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.s_components">[docs]</a>	<span class="k">def</span> <span class="nf">s_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Same as s_connected_components</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_connected_components</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.connected_components"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.connected_components">[docs]</a>	<span class="k">def</span> <span class="nf">connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Same as :meth:`s_connected_components` with s=1.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_connected_components</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.connected_component_subgraphs"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.connected_component_subgraphs">[docs]</a>	<span class="k">def</span> <span class="nf">connected_component_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Same as :meth:`s_component_subgraphs` with s=1</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_component_subgraphs</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span></div>


<div class="viewcode-block" id="Hypergraph.components"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.components">[docs]</a>	<span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Same as :meth:`s_connected_components` with s=1</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_components</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.component_subgraphs"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.component_subgraphs">[docs]</a>	<span class="k">def</span> <span class="nf">component_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Same as :meth:`s_components_subgraphs` with s=1</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_component_subgraphs</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.node_diameters"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.node_diameters">[docs]</a>	<span class="k">def</span> <span class="nf">node_diameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the node diameters of the connected components in hypergraph.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>


<span class="sd">		Returns:</span>
<span class="sd">		an array of the diameters of the s-components and </span>
<span class="sd">		an array of the s-component nodes.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">A</span><span class="p">,</span><span class="n">coldict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> 
		<span class="n">diams</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">comps</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
		    <span class="n">diamc</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		    <span class="n">temp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
		    	<span class="n">temp</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coldict</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
		    <span class="n">comps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
		    <span class="n">diams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diamc</span><span class="p">)</span>
		<span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">diams</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">diams</span><span class="p">[</span><span class="n">loc</span><span class="p">],</span> <span class="n">diams</span><span class="p">,</span> <span class="n">comps</span></div>

<div class="viewcode-block" id="Hypergraph.edge_diameters"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.edge_diameters">[docs]</a>	<span class="k">def</span> <span class="nf">edge_diameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the edge diameters of the s_edge_connected component subgraphs </span>
<span class="sd">		in hypergraph.</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		s : int, optional, default: 1</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		maximum diameter : int</span>

<span class="sd">		list of diameters : list</span>
<span class="sd">			List of edge_diameters for s-edge component subgraphs in hypergraph</span>

<span class="sd">		list of component : list</span>
<span class="sd">			List of the edge uids in the s-edge component subgraphs.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">A</span><span class="p">,</span><span class="n">coldict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> 
		<span class="n">diams</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">comps</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
		    <span class="n">diamc</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		    <span class="n">temp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
		    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
		    	<span class="n">temp</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coldict</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
		    <span class="n">comps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
		    <span class="n">diams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diamc</span><span class="p">)</span>
		<span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">diams</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">diams</span><span class="p">[</span><span class="n">loc</span><span class="p">],</span> <span class="n">diams</span><span class="p">,</span> <span class="n">comps</span></div>

<div class="viewcode-block" id="Hypergraph.diameter"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.diameter">[docs]</a>	<span class="k">def</span> <span class="nf">diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the length of the longest shortest s-walk between nodes in hypergraph</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		s : int, optional, default: 1</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		diameter : int</span>

<span class="sd">		Raises</span>
<span class="sd">		------</span>
<span class="sd">		HyperNetXError</span>
<span class="sd">			If hypergraph is not s-edge-connected</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Two nodes are s-adjacent if they share s edges.</span>
<span class="sd">		Two nodes v_start and v_end are s-walk connected if there is a sequence of</span>
<span class="sd">		nodes v_start, v_1, v_2, ... v_n-1, v_end such that consecutive nodes</span>
<span class="sd">		are s-adjacent. If the graph is not connected, an error will be raised.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
		<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Hypergraph is not s-connected. s=</span><span class="si">{s}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.edge_diameter"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.edge_diameter">[docs]</a>	<span class="k">def</span> <span class="nf">edge_diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the length of the longest shortest s-walk between edges in hypergraph</span>
<span class="sd">		</span>
<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		s : int, optional, default: 1</span>

<span class="sd">		Return</span>
<span class="sd">		------</span>
<span class="sd">		edge_diameter : int</span>

<span class="sd">		Raises</span>
<span class="sd">		------</span>
<span class="sd">		HyperNetXError</span>
<span class="sd">			If hypergraph is not s-edge-connected</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		Two edges are s-adjacent if they share s nodes.</span>
<span class="sd">		Two nodes e_start and e_end are s-walk connected if there is a sequence of</span>
<span class="sd">		edges e_start, e_1, e_2, ... e_n-1, e_end such that consecutive edges</span>
<span class="sd">		are s-adjacent. If the graph is not connected, an error will be raised.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
		<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Hypergraph is not s-connected. s=</span><span class="si">{s}</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Hypergraph.distance"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.distance">[docs]</a>	<span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the shortest s-walk distance between two nodes in the hypergraph.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------  </span>
<span class="sd">		source : node.uid or node</span>
<span class="sd">			a node in the hypergraph   </span>

<span class="sd">		target : node.uid or node</span>
<span class="sd">			a node in the hypergraph  </span>

<span class="sd">		s : positive integer </span>
<span class="sd">			the number of edges</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		s-walk distance : int</span>

<span class="sd">		See Also</span>
<span class="sd">		--------</span>
<span class="sd">		edge_distance</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		The s-distance is the shortest s-walk length between the nodes.</span>
<span class="sd">		An s-walk between nodes is a sequence of nodes that pairwise share</span>
<span class="sd">		at least s edges. The length of the shortest s-walk is 1 less than</span>
<span class="sd">		the number of nodes in the path sequence.</span>

<span class="sd">		Uses the networkx shortest_path_length method on the graph</span>
<span class="sd">		generated by the s-adjacency matrix.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
			<span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">uid</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
			<span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">uid</span>
		<span class="n">A</span><span class="p">,</span><span class="n">rowdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="n">rkey</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">rowdict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">path</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">rkey</span><span class="p">[</span><span class="n">source</span><span class="p">],</span><span class="n">rkey</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">path</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;No </span><span class="si">{s}</span><span class="s1">-path between </span><span class="si">{source}</span><span class="s1"> and </span><span class="si">{target}</span><span class="s1">&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>

<div class="viewcode-block" id="Hypergraph.edge_distance"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.edge_distance">[docs]</a>	<span class="k">def</span> <span class="nf">edge_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">source</span><span class="p">,</span><span class="n">target</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Returns the shortest s-walk distance between two edges in the hypergraph.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------  </span>
<span class="sd">		source : edge.uid or edge</span>
<span class="sd">			an edge in the hypergraph </span>

<span class="sd">		target : edge.uid or edge</span>
<span class="sd">			an edge in the hypergraph  </span>

<span class="sd">		s : positive integer </span>
<span class="sd">			the number of intersections between pairwise consecutive edges</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		s-walk distance : the shortest s-walk edge distance</span>
<span class="sd">			A shortest s-walk is computed as a sequence of edges,</span>
<span class="sd">			the s-walk distance is the number of edges in the sequence</span>
<span class="sd">			minus 1. If no such path exists returns np.inf.</span>

<span class="sd">		See Also</span>
<span class="sd">		--------</span>
<span class="sd">		distance</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">			The s-distance is the shortest s-walk length between the edges.</span>
<span class="sd">			An s-walk between edges is a sequence of edges such that consecutive pairwise </span>
<span class="sd">			edges intersect in at least s nodes. The length of the shortest s-walk is 1 less than</span>
<span class="sd">			the number of edges in the path sequence.</span>

<span class="sd">			Uses the networkx shortest_path_length method on the graph</span>
<span class="sd">			generated by the s-edge_adjacency matrix.</span>

<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
			<span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">uid</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="n">Entity</span><span class="p">):</span>
			<span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">uid</span>
		<span class="n">A</span><span class="p">,</span><span class="n">coldict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
		<span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
		<span class="n">ckey</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">coldict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">path</span> <span class="o">=</span>  <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">ckey</span><span class="p">[</span><span class="n">source</span><span class="p">],</span><span class="n">ckey</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">path</span>
		<span class="k">except</span><span class="p">:</span>
			<span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;No </span><span class="si">{s}</span><span class="s1">-path between </span><span class="si">{source}</span><span class="s1"> and </span><span class="si">{target}</span><span class="s1">&#39;</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>

<div class="viewcode-block" id="Hypergraph.from_bipartite"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.from_bipartite">[docs]</a>	<span class="nd">@classmethod</span>
	<span class="k">def</span> <span class="nf">from_bipartite</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">set_names</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Static method creates a Hypergraph from a bipartite graph.</span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>

<span class="sd">		B: nx.Graph()</span>
<span class="sd">			A networkx bipartite graph. Each node in the graph has a property</span>
<span class="sd">			&#39;bipartite&#39; taking one of two values</span>

<span class="sd">		set_names: iterable</span>
<span class="sd">			An ordered list :math:`[x_0, x_1]`, corresponding to the values </span>
<span class="sd">			assigned to the bipartite property in B.</span>

<span class="sd">		name: hashable</span>

<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		new hypergraph : Hypergraph</span>

<span class="sd">		Notes</span>
<span class="sd">		-----</span>
<span class="sd">		A partition for the nodes in a bipartite graph generates a hypergraph as follows.</span>
<span class="sd">		For each node n in B with bipartite property equal to set_names[0] there is a </span>
<span class="sd">		node n in the hypergraph.  For each node e in B with bipartite property</span>
<span class="sd">		equal to set_names[1], there is an edge in the hypergraph. </span>
<span class="sd">		For each edge (n,e) in B add n to the edge e in the hypergraph.</span>

<span class="sd">		&quot;&quot;&quot;</span> 

		<span class="k">if</span> <span class="ow">not</span> <span class="n">bipartite</span><span class="o">.</span><span class="n">is_bipartite</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
			<span class="k">raise</span> <span class="n">HyperNetxError</span><span class="p">(</span><span class="s1">&#39;Error: Method requires a bipartite graph.&#39;</span><span class="p">)</span>
		<span class="n">entities</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="n">B</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
		    <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;bipartite&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">set_names</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
		        <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>
		        <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">B</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
		            <span class="n">elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Entity</span><span class="p">(</span><span class="n">nei</span><span class="p">,[],</span><span class="n">properties</span><span class="o">=</span><span class="n">B</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">nei</span><span class="p">]))</span>
		        <span class="k">if</span> <span class="n">elements</span><span class="p">:</span>
		            <span class="n">entities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Entity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">elements</span><span class="p">,</span><span class="n">properties</span><span class="o">=</span><span class="n">d</span><span class="p">))</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;_&#39;</span>
		<span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="n">EntitySet</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">entities</span><span class="p">),</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Hypergraph.from_numpy_array"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.from_numpy_array">[docs]</a>	<span class="nd">@classmethod</span>
	<span class="k">def</span> <span class="nf">from_numpy_array</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">node_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edge_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Create a hypergraph from a real valued matrix represented as a numpy array with dimensions 2x2 </span>
<span class="sd">		The matrix is converted to a matrix of 0&#39;s and 1&#39;s so that any truthy cells are converted to 1&#39;s and </span>
<span class="sd">		all others to 0&#39;s. </span>

<span class="sd">		Parameters</span>
<span class="sd">		----------</span>
<span class="sd">		M : real valued array-like object, dimensions=2x2</span>
<span class="sd">		    representing a real valued matrix with rows corresponding to nodes and columns to edges</span>

<span class="sd">		node_names : object, array-like, default=None</span>
<span class="sd">		    List of node names must be the same length as M.shape[0]. </span>
<span class="sd">		    If None then the node names correspond to row indices with &#39;v&#39; prepended.</span>

<span class="sd">		edge_names : object, array-like, default=None</span>
<span class="sd">		    List of edge names must have the same length as M.shape[1]. </span>
<span class="sd">		    If None then the edge names correspond to column indices with &#39;e&#39; prepended.</span>

<span class="sd">		name : hashable</span>

<span class="sd">		key : (optional) function</span>
<span class="sd">			boolean function to be evaluated on each cell of the array</span>
<span class="sd">		    </span>
<span class="sd">		Returns</span>
<span class="sd">		-------</span>
<span class="sd">		 : Hypergraph</span>

<span class="sd">		Note</span>
<span class="sd">		----</span>
<span class="sd">		The constructor does not generate empty edges. </span>
<span class="sd">		All zero columns in M are removed and the names corresponding to these</span>
<span class="sd">		edges are discarded.</span>


<span class="sd">		&quot;&quot;&quot;</span>  	    
		<span class="c1">## Create names for nodes and edges</span>
		<span class="c1">## Validate the size of the node and edge arrays</span>

		<span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">):</span>
			<span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s1">&#39;Input requires a 2 dimensional numpy array&#39;</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">node_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		    <span class="n">nodenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span>
		    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodenames</span><span class="p">)</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
		        <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s1">&#39;Number of node names does not match number of rows.&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
		    <span class="n">nodenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">f</span><span class="s1">&#39;v</span><span class="si">{idx}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>

		<span class="k">if</span> <span class="n">edge_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		    <span class="n">edgenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_names</span><span class="p">)</span>
		    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgenames</span><span class="p">)</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
		    	<span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s1">&#39;Number of edge_names does not match number of columns.&#39;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
		    <span class="n">edgenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">f</span><span class="s1">&#39;e</span><span class="si">{jdx}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">jdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>

		<span class="c1">## apply boolean key if available</span>
		<span class="k">if</span> <span class="n">key</span><span class="p">:</span>
			<span class="n">M</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

		<span class="c1">## Remove empty column indices from M columns and edgenames</span>
		<span class="n">colidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">jdx</span> <span class="k">for</span> <span class="n">jdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">M</span><span class="p">[:,</span><span class="n">jdx</span><span class="p">])])</span>
		<span class="n">colidxsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">colidx</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">colidxsum</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">Hypergraph</span><span class="p">()</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:,</span><span class="n">colidx</span><span class="p">]</span>
			<span class="n">edgenames</span> <span class="o">=</span> <span class="n">edgenames</span><span class="p">[</span><span class="n">colidx</span><span class="p">]</span>
			<span class="n">edict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
			<span class="c1">## Create an EntitySet of edges from M         </span>
			<span class="k">for</span> <span class="n">jdx</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edgenames</span><span class="p">):</span>
			    <span class="n">edict</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodenames</span><span class="p">[[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">jdx</span><span class="p">]]]</span>		            
			<span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="n">edict</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="Hypergraph.from_dataframe"><a class="viewcode-back" href="../../classes/classes.html#classes.hypergraph.Hypergraph.from_dataframe">[docs]</a>	<span class="nd">@classmethod</span>
	<span class="k">def</span> <span class="nf">from_dataframe</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">fillna</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	    Create a hypergraph from a Pandas Dataframe object using index to label vertices</span>
<span class="sd">	    and Columns to label edges. </span>

<span class="sd">	    Parameters</span>
<span class="sd">	    ----------</span>
<span class="sd">	    df : Pandas.Dataframe</span>
<span class="sd">	        a real valued dataframe with a single index</span>

<span class="sd">	    fillna : float, default = 0</span>
<span class="sd">	        a real value to place in empty cell, all-zero columns will not generate</span>
<span class="sd">	        an edge</span>

<span class="sd">	    transpose : bool, default = False</span>
<span class="sd">	        option to transpose the dataframe, in this case df.Index will label the edges</span>
<span class="sd">	        and df.columns will label the nodes</span>

<span class="sd">	    key : (optional) function</span>
<span class="sd">			boolean function to be evaluated on each cell of the array</span>
<span class="sd">	        </span>
<span class="sd">	    Returns</span>
<span class="sd">	    -------</span>
<span class="sd">	    : Hypergraph</span>

<span class="sd">	    Note</span>
<span class="sd">	    ----</span>
<span class="sd">	    The constructor does not generate empty edges. </span>
<span class="sd">	    All-zero columns in df are removed and the names corresponding to these</span>
<span class="sd">	    edges are discarded.    </span>
<span class="sd">	    &#39;&#39;&#39;</span>
	    <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

	    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pd</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
	        <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s1">&#39;Error: Input object must be a pandas dataframe.&#39;</span><span class="p">)</span> 
	    <span class="k">if</span> <span class="n">transpose</span><span class="p">:</span>
	        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>   
	    <span class="n">node_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
	    <span class="n">edge_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
	    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fillna</span><span class="p">)</span>
	    <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
	    	<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
	    <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_numpy_array</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">node_names</span><span class="o">=</span><span class="n">node_names</span><span class="p">,</span><span class="n">edge_names</span><span class="o">=</span><span class="n">edge_names</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div></div>





</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018 Battelle Memorial Institute

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>